# This script aims to compute the flow in a channel with a moving bottom wall
# We use the fluid solver
# Fluid parameters values corresponds to the PVS problem
# pressure difference : 1 mmHg = 1330 dyn/cm2

from sleep.fbb_DD.domain_transfer import transfer_into
from sleep.fbb_DD.solid import solve_solid
from sleep.fbb_DD.fluid_NS import solve_fluid
from sleep.fbb_DD.ale import solve_ale
from sleep.utils import EmbeddedMesh
from sleep.mesh import load_mesh2d
from dolfin import *


# We get the fluid domain mesh from the full PVS mesh
h5_filename = '../mesh/test/fbb_domain.h5'
# The mesh is typically generated by sleep/mesh/fbb_mesh.py
mesh, markers, lookup = load_mesh2d(h5_filename)
cell_f, facet_f = markers
cell_lookup, facet_lookup = lookup['cell'], lookup['facet']
# The mesh has 3 subdomains: corresponding to fluid and two Biot domain. 
# We now split into fluid and solid meshes in order to keep only the fluid mesh
mesh_f = EmbeddedMesh(cell_f, cell_lookup['F'])
mesh_s = EmbeddedMesh(cell_f, (cell_lookup['S1'], cell_lookup['S2']))

# We get the boundary markers
fluid_markers = ('F_left', 'F_bottom', 'F_right', 'I_bottom')
fluid_markers = tuple(facet_lookup[k] for k in fluid_markers)
fluid_bdries = mesh_f.translate_markers(facet_f, fluid_markers)

# Parameters setup ------------------------------------------------ FIXME

fluid_parameters = {'mu': 7e-2, 'rho': 1, 'dt':1e-4}
ale_parameters = {'kappa': Constant(1.0)}



# Setup fem spaces ---------------------------------------------------
Vf_elm = VectorElement('Lagrange', triangle, 2)
Qf_elm = FiniteElement('Lagrange', triangle, 1)
Wf_elm = MixedElement([Vf_elm, Qf_elm])
Wf = FunctionSpace(mesh_f, Wf_elm)

Va_elm = VectorElement('Lagrange', triangle, 1)
Va = FunctionSpace(mesh_f, Va_elm)

# Setup of boundary conditions ----------------------------------- FIXME

import sympy
ts = sympy.symbols("time")

t1 = sympy.symbols("t1")
t2 = sympy.symbols("t2")
sin = sympy.sin

amp=1e-4 #cm
f=1 #Hz

functionU = amp*sin(2*pi*f*t1) # displacement
U_vessel = sympy.printing.ccode(functionU)

#functionV = amp*(sin(2*pi*f*t2)-sin(2*pi*f*t1))/(t2-t1) # velocity
functionV = sympy.diff(functionU,t1) # velocity
V_vessel = sympy.printing.ccode(functionV)

functionUALE=amp*(sin(2*pi*f*t2)-sin(2*pi*f*t1))
UALE_vessel = sympy.printing.ccode(functionUALE)



pf_in = Constant(1330)           # sigma_f.n.n on the inflow F_left boundary
#pf_out = Constant(0)           # sigma_f.n.n on the outflow F_right boundary



uf_bottom = Expression(('0',V_vessel ), t1 = 0, t2=1, degree=2)   # no slip condition + vessel wall at the bottomuf_top = Expression(('0','0'), time = 0, degree=2)   # no slip condition at the top
uf_top=Constant((0,0)) # no slip condition

ale_u_bottom = Expression(('0',UALE_vessel ), t1 = 0, t2=1, degree=2) # displacement for ALE of the bottom wall
ale_u_top = Constant((0,0)) # displacement for ALE of the top wall

# We collect the time dependent BC for update
driving_expressions = (uf_bottom,ale_u_bottom)

# Now we wire up
bcs_fluid = {'velocity': [(facet_lookup['F_bottom'], uf_bottom),
                            ((facet_lookup['I_bottom'], uf_top))],
            'velocity_x': [(facet_lookup['F_right'], Constant(0))],
             'traction': [],  
             'pressure': [(facet_lookup['F_left'], pf_in)]}

bcs_ale = {'dirichlet': [(facet_lookup['F_bottom'], ale_u_bottom),
                         (facet_lookup['I_bottom'], ale_u_top)],
           'neumann': [(facet_lookup['F_left'], Constant((0, 0))),
                       (facet_lookup['F_right'], Constant((0, 0)))]}

# Define functions for solutions at previous and current time steps
uf_n = project(Constant((0, 0)), Wf.sub(0).collapse())
pf_n =  project(Constant(0), Wf.sub(1).collapse())


# Time loop
time = 0.
timestep=0


Toutput=0.01

tfinal=1

uf_out, pf_out, etaf_out = File('./output/NS_moving_wall/uf.pvd'), File('./output/NS_moving_wall/pf.pvd'), File('./output/NS_moving_wall/etaf.pvd')

uf_n.rename("uf", "tmp")
pf_n.rename("pf", "tmp")

uf_out << (uf_n, time)
pf_out << (pf_n, time)

while time < tfinal:
    time += fluid_parameters['dt']
    timestep+=1

    # Set sources if they are time dependent
    for expr in driving_expressions:
        hasattr(expr, 't1') and setattr(expr, 't1', time)
        hasattr(expr, 't2') and setattr(expr, 't2', time+fluid_parameters['dt'])

    # Solve fluid problem
    uf_, pf_ = solve_fluid(Wf, f=Constant((0, 0)), u_n=uf_n, p_n=pf_n,  bdries=fluid_bdries, bcs=bcs_fluid,
                           parameters=fluid_parameters)

    # Update current solution
    uf_n.assign(uf_)
    pf_n.assign(pf_)
    
    # Solve ALE
    # compute the displacement
    #ale_u_bottom=Expression((UALE_vessel,'0'), t1 = time, t2=time+dt, degree=2) 

    eta_f = solve_ale(Va, f=Constant((0, 0)), bdries=fluid_bdries, bcs=bcs_ale,
                      parameters=ale_parameters)
    
    # Move domains
    ALE.move(mesh_f, eta_f)

    # Save output
    if(timestep % int(Toutput/fluid_parameters['dt']) == 0):

        eta_f.rename("eta_f", "tmp")

        etaf_out << (eta_f, time)
 
        uf_.rename("uf", "tmp")
        pf_.rename("pf", "tmp")

        uf_out << (uf_, time)
        pf_out << (pf_, time)

