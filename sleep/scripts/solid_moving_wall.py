from sleep.fbb_DD.domain_transfer import transfer_into
from sleep.fbb_DD.solid2 import solve_solid
from sleep.fbb_DD.fluid import solve_fluid
from sleep.fbb_DD.ale import solve_ale
from sleep.utils import EmbeddedMesh
from sleep.mesh import load_mesh2d
from dolfin import *


## Todo 
# the permeability in the membrane is not isotrop, it is only in the normal direction. 
# we should use a tensor here


#########################
##load the mesh
h5_filename = '../mesh/test/fbb_domain.h5'
# The mesh is typically generated by sleep/mesh/fbb_mesh.py
mesh, markers, lookup = load_mesh2d(h5_filename,json_file='../mesh/test/fbb_domain.json')
cell_f, facet_f = markers
cell_lookup, facet_lookup = lookup['cell'], lookup['facet']
# The mesh has 3 subdomains: corrwsponding to fluid and two Biot domain. 
# Since our approach is to solve the subproblems isolated we now split 
# into fluid and solid meshes and keep only the solid part
mesh_f = EmbeddedMesh(cell_f, cell_lookup['F'])
mesh_s = EmbeddedMesh(cell_f, (cell_lookup['S1'], cell_lookup['S2']))

# Get the boundary markers
solid_markers = ('I_top', 'I_bottom', 'S1_left', 'S1_right', 'S2_left', 'S2_right', 'S2_top') # I had to modify the .json to get Itop and I bottom correct
solid_markers = tuple(facet_lookup[k] for k in solid_markers)
solid_bdries = mesh_s.translate_markers(facet_f, solid_markers)
print(facet_lookup)
print(cell_lookup)
# We do not need to keep the facets marking the solid-solid interface
values = solid_bdries.array()
values[values == facet_lookup['I_top']] = 0

File('./test/fbb_facets.pvd') << solid_bdries
File('./test/fbb_cells.pvd') << cell_f

# Parameters setup ------------------------------------------------ FIXME
kappa_2=3.3e-12/6.97e-3 # for the tests I allow more flow
kappa_3=2e-11/6.97e-3 # cm2/(g.cm-1.s-1)
E_2=1000e3 # g.cm.s
E_3=100e3 # g.cm.s
poisson=0.45 # g.cm.s

alpha_2=1.0
alpha_3=1.0



#-----------------------------------
mu_2=E_2/(2*(1+poisson))
mu_3=E_3/(2*(1+poisson))
lmbda_2=E_2*poisson/(1+poisson)/(1-2*poisson)
lmbda_3=E_3*poisson/(1+poisson)/(1-2*poisson)
s0_2=1/lmbda_2
s0_3=1/lmbda_3

# For parameters not that Biot has two subdomains (which are marked in the
# mesh so we difine discontinuous functions for them
# For the tests I put same coef every where
solid_parameters = {'kappa_2': kappa_2, 'kappa_3': kappa_3,
                    'mu_2': mu_2, 'mu_3':mu_3,
                    'lmbda_2': lmbda_2, 'lmbda_3': lmbda_3,
                    'alpha_2': alpha_2, 'alpha_3': alpha_3,
                    's0_2': s0_2, 's0_3': s0_3}  

# NOTE: Here we do P0 projection
dxSolid = Measure('dx', domain=mesh_s, subdomain_data=mesh_s.marking_function)
CoefSpace = FunctionSpace(mesh_s, 'DG', 0)
q = TestFunction(CoefSpace)

for coef in ('kappa', 'mu', 'lmbda', 'alpha', 's0'):
    # Remove
    two = solid_parameters.pop('%s_2' % coef)
    three = solid_parameters.pop('%s_3' % coef)

    form = ((1/CellVolume(mesh_s))*two*q*dxSolid(cell_lookup['S1']) +
            (1/CellVolume(mesh_s))*three*q*dxSolid(cell_lookup['S2']))
    
    solid_parameters[coef] = Function(CoefSpace, assemble(form))

File('./test/fbb_mu.pvd') << solid_parameters['mu']
    
# Setup fem spaces ---------------------------------------------------
Es_elm = VectorElement('Lagrange', triangle, 2)
Vs_elm = FiniteElement('Raviart-Thomas', triangle, 1)
Qs_elm = FiniteElement('Discontinuous Lagrange', triangle, 0)
Ws_elm = MixedElement([Es_elm, Vs_elm, Qs_elm])
Ws = FunctionSpace(mesh_s, Ws_elm)

# ALE displacement in the solid
Va_s = VectorFunctionSpace(mesh_s, 'CG', 1)

# Setup of boundary conditions ----------------------------------- FIXME

# In the tissue domain + membrane domain
# Bottom face : displacement of the vessel wall + flow condition 
# Top face : kind of symmetry, ie. no displacement and no flow in normal direction
# Left face : SAS interface, imposed fluid pressure, free solid stress, ie total stress = - pressure in SAS
# Right face : inner brain interface : to be defined
#               * zero derivative of stress and flow ? 
#               *** no flow, no displacement in normal direction # I will try this one
#               * resistance for normal flow and no normal displacement

# remarque : 
# I should set zero flow on left and side for the membrane and total normal stress equal - pressure in SAS.

import sympy
ts = sympy.symbols("time")
sin = sympy.sin

t1 = sympy.symbols("t1")
t2 = sympy.symbols("t2")


amp=3e-4 #cm
f=1 #Hz

# vessel :  * U imposed
#           * q = -dU/dt * porosity ? or q=0
#
# top :  * U.n=0
#        * q=0
#
# right :* U.n=0
#        * q=0
#
# left : * tn=0
#        * p=0
#


# displacement from origin
functionU = amp*sin(2*pi*f*t1) 
U_vessel = sympy.printing.ccode(functionU)


# displacement on the time step
functionUlocal=amp*(sin(2*pi*f*t2)-sin(2*pi*f*t1))
U_vessel_local = sympy.printing.ccode(functionUlocal)


us_bottom = Expression(('0',  U_vessel_local ), t1 = 0, t2=1, degree=2) # displacement at the bottom wall


ps_left = Constant(0)  # Fluid pressure in the porous medium at the interface with the SAS

# Normal flow so only one component
flux_right = Constant((0))  # Right flow for test


amp2=100 #dyn/cm2
functionP = amp2*sin(2*pi*f*t1) 
P_vessel = sympy.printing.ccode(functionP)

p_bottom=Expression(P_vessel, t1 = 0, degree=1) 

# We collect them for easier updates in the loop. If they have time attribute
# it will be set
driving_expressions = (us_bottom, ps_left,p_bottom)



bcs_solid = {
    'elasticity': {
        'displacement': [(facet_lookup['I_bottom'],Constant((0,0)))],
        'traction': [(facet_lookup['S1_left'],Constant((0,0))),
                 (facet_lookup['S2_left'], Constant((0,0))),
                 (facet_lookup['S2_right'], Constant((0,0))),
                 (facet_lookup['S1_right'], Constant((0,0))),
                 (facet_lookup['S2_top'], Constant((0,0)))],
        'displacement_x' : [],
        'displacement_y' : []                         
    },
    'darcy': {
        'pressure': [(facet_lookup['I_bottom'], p_bottom),
                     (facet_lookup['S2_top'], Constant(0))],
        'flux': [(facet_lookup['S1_left'],Constant((0,0))),
                 (facet_lookup['S2_left'], Constant((0,0))),
                 (facet_lookup['S2_right'], Constant((0,0))),
                 (facet_lookup['S1_right'], Constant((0,0)))]     
    }
}

# Get the initial conditions ------------------------------------- FIXME
Es = Ws.sub(0).collapse()
Qs = Ws.sub(2).collapse()


# What is the difference between project and interpolate?
eta_s0 = project(Constant((0, 0)), Es)
p_s0 = project(Constant(0), Qs)
u_s0 = project(Constant((0, 0)), Ws.sub(1).collapse()) 


# Add things for time stepping
solid_parameters['dt'] = 1E-3  # FIXME
#solid_parameters['nsteps'] = 1 # I supressed the steping in the solver



# Splitting loop
time = 0.
timestep=0


Toutput=0.01

tfinal=1



us_out, ps_out, etas_out = File('./output/solid_moving_wall/us.pvd'), File('./output/solid_moving_wall/ps.pvd'),File('./output/solid_moving_wall/etas.pvd')

while time < tfinal:
    time += solid_parameters['dt']
    # Set sources if they are time dependent
    for expr in driving_expressions:
        hasattr(expr, 'time') and setattr(expr, 'time', time)
        hasattr(expr, 't1') and setattr(expr, 't1', time)
        hasattr(expr, 't2') and setattr(expr, 't2', time+solid_parameters['dt'])

    
    solid_parameters['T0'] = time   
    eta_s, u_s, p_s = solve_solid(Ws, f1=Constant((0, 0)), f2=Constant(0), eta_0=eta_s0, p_0=p_s0,
                                            bdries=solid_bdries, bcs=bcs_solid, parameters=solid_parameters)


    # Move both domains(under some sensible condition) FIXME
    if True:
        ALE.move(mesh_s, interpolate(eta_s, Va_s))



    # Reassign initial conditions
    #eta_s0.assign(eta_s)
    u_s0.assign(u_s)
    p_s0.assign(p_s)

    # Save output
    timestep+=1
    if(timestep % int(Toutput/solid_parameters['dt']) == 0):


        eta_s.rename("etas", "tmp")
        u_s.rename("us", "tmp")
        p_s.rename("ps", "tmp")

        etas_out << (eta_s, time)
        us_out << (u_s, time)
        ps_out << (p_s, time)
