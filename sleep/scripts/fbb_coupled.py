from sleep.fbb_DD.domain_transfer import transfer_into
from sleep.fbb_DD.solid2 import solve_solid
from sleep.fbb_DD.fluid import solve_fluid
from sleep.fbb_DD.ale import solve_ale
from sleep.utils import EmbeddedMesh
from sleep.mesh import load_mesh2d
from dolfin import *
import sleep.fbb_DD.cylindrical as cyl
#########################
##load the mesh
h5_filename = '../mesh/test/fbb_domain.h5'
# The mesh is typically generated by sleep/mesh/fbb_mesh.py
mesh, markers, lookup = load_mesh2d(h5_filename)
cell_f, facet_f = markers
cell_lookup, facet_lookup = lookup['cell'], lookup['facet']
# The mesh has 3 subdomains: corrwsponding to fluid and two Biot domain. 
# Since our approach is to solve the subproblems isolated we now split 
# into fluid and solid meshes and keep only the solid part
mesh_f = EmbeddedMesh(cell_f, cell_lookup['F'])
mesh_s = EmbeddedMesh(cell_f, (cell_lookup['S1'], cell_lookup['S2']))

# Get the boundary markers
solid_markers = ('I_top', 'I_bottom', 'S1_left', 'S1_right', 'S2_left', 'S2_right', 'S2_top') # I had to modify the .json to get Itop and I bottom correct
solid_markers = tuple(facet_lookup[k] for k in solid_markers)
solid_bdries = mesh_s.translate_markers(facet_f, solid_markers)
print(facet_lookup)
print(cell_lookup)
# We do not need to keep the facets marking the solid-solid interface
values = solid_bdries.array()
values[values == facet_lookup['I_top']] = 0

File('./test/fbb_facets.pvd') << solid_bdries
File('./test/fbb_cells.pvd') << cell_f

# We get the boundary markers
fluid_markers = ('F_left', 'F_bottom', 'F_right', 'I_bottom')
fluid_markers = tuple(facet_lookup[k] for k in fluid_markers)
fluid_bdries = mesh_f.translate_markers(facet_f, fluid_markers)


### BIOT PARAMETERS
# Parameters setup ------------------------------------------------ FIXME
kappa_2=3.3e-13/6.97e-3 # for the tests I allow more flow
kappa_3=2e-11/6.97e-3 # cm2/(g.cm-1.s-1)
E_2=1000e3 # g.cm.s
E_3=100e3 # g.cm.s
poisson=0.45 # g.cm.s

alpha_2=1.0
alpha_3=1.0



#-----------------------------------
mu_2=E_2/(2*(1+poisson))
mu_3=E_3/(2*(1+poisson))
lmbda_2=E_2*poisson/(1+poisson)/(1-2*poisson)
lmbda_3=E_3*poisson/(1+poisson)/(1-2*poisson)
s0_2=1/lmbda_2
s0_3=1/lmbda_3

# For parameters not that Biot has two subdomains (which are marked in the
# mesh so we difine discontinuous functions for them
# For the tests I put same coef every where
solid_parameters = {'kappa_2': kappa_2, 'kappa_3': kappa_2,
                    'mu_2': mu_2, 'mu_3':mu_2,
                    'lmbda_2': lmbda_2, 'lmbda_3': lmbda_2,
                    'alpha_2': alpha_2, 'alpha_3': alpha_2,
                    's0_2': s0_2, 's0_3': s0_2}  

porosity_n=Constant(0.2)


### FLUID PARAMETERS
fluid_parameters = {'mu': 6.97e-3, 'rho': 1}


# NOTE: Here we do P0 projection
dxSolid = Measure('dx', domain=mesh_s, subdomain_data=mesh_s.marking_function)
CoefSpace = FunctionSpace(mesh_s, 'DG', 0)
q = TestFunction(CoefSpace)

for coef in ('kappa', 'mu', 'lmbda', 'alpha', 's0'):
    # Remove
    two = solid_parameters.pop('%s_2' % coef)
    three = solid_parameters.pop('%s_3' % coef)

    form = ((1/CellVolume(mesh_s))*two*q*dxSolid(cell_lookup['S1']) +
            (1/CellVolume(mesh_s))*three*q*dxSolid(cell_lookup['S2']))
    
    solid_parameters[coef] = Function(CoefSpace, assemble(form))
    
ale_parameters = {'kappa': Constant(1.0)}

# Setup fem spaces ---------------------------------------------------
Vf_elm = VectorElement('Lagrange', triangle, 2)
Qf_elm = FiniteElement('Lagrange', triangle, 1)
Wf_elm = MixedElement([Vf_elm, Qf_elm])
Wf = FunctionSpace(mesh_f, Wf_elm)

Es_elm = VectorElement('Lagrange', triangle, 2)
Vs_elm = FiniteElement('Raviart-Thomas', triangle, 1)
Qs_elm = FiniteElement('Discontinuous Lagrange', triangle, 0)
Ws_elm = MixedElement([Es_elm, Vs_elm, Qs_elm])
Ws = FunctionSpace(mesh_s, Ws_elm)

Va_elm = VectorElement('Lagrange', triangle, 1)
Va = FunctionSpace(mesh_f, Va_elm)

# Setup of boundary conditions ----------------------------------- FIXME

import sympy
ts = sympy.symbols("time")
sin = sympy.sin

t1 = sympy.symbols("t1")
t2 = sympy.symbols("t2")
sin = sympy.sin

amp=18e-4 #cm
f=1 #Hz

functionU = amp*sin(2*pi*f*t1) # displacement
U_vessel = sympy.printing.ccode(functionU)

#functionV = amp*(sin(2*pi*f*t2)-sin(2*pi*f*t1))/(t2-t1) # velocity
functionV = sympy.diff(functionU,t1) # velocity
V_vessel = sympy.printing.ccode(functionV)

functionUALE=amp*(sin(2*pi*f*t2)-sin(2*pi*f*t1))
UALE_vessel = sympy.printing.ccode(functionUALE)

pSAS = Constant(0)           # sigma_f.n.n on the inflow F_left boundary

uf_bottom = Expression(('0',V_vessel ), t1 = 0, t2=1, degree=2)   # no slip condition + vessel wall at the bottom

ale_u_bottom = Expression(('0',UALE_vessel ), t1 = 0, t2=1, degree=2) # displacement for ALE of the bottom wall


# We collect them for easier updates in the loop. If they have time attribute
# it will be set
driving_expressions = (pSAS,uf_bottom, ale_u_bottom)



##### Interface condition functions
# These are realted to interface conditions. We will compute traction from
# solid and apply to fluid. Then from fluid unknowns we will compute pressure
# and displacement. These quantities need to be represented in FEM spaces
# of the solver. Thus
#traction_f_iface = Function(VectorFunctionSpace(mesh_f, 'DG', 1))  # FIXME: DG0? to be safe

velocity_f_iface = Function(VectorFunctionSpace(mesh_f, 'DG', 1))  # FIXME: DG0? to be safe

etas_iface = Function(VectorFunctionSpace(mesh_s, 'CG', 2))
aux = Function(VectorFunctionSpace(mesh_s, 'CG', 2))  # Auxiliary for u_s.np.np


ps_iface = Function(FunctionSpace(mesh_s, 'DG', 0))
tractions_iface = Function(VectorFunctionSpace(mesh_s, 'DG', 1))  # FIXME: DG0? to be safe

# For ALE we will cary the displacement to fluid domain
etaf_iface = Function(VectorFunctionSpace(mesh_f, 'CG', 2))


######


# Now we wire up
bcs_fluid = {'velocity': [(facet_lookup['F_bottom'], uf_bottom), # No-gap condition on imposed displacement
                          (facet_lookup['I_bottom'], velocity_f_iface),
                          (facet_lookup['F_right'], Constant((0,0)))], # Velocity imposed at the interface
#            'velocity_x': [],
             'traction': [],  
             'pressure': [(facet_lookup['F_left'], pSAS)]}

bcs_ale = {'dirichlet': [(facet_lookup['F_bottom'], ale_u_bottom),
                         (facet_lookup['I_bottom'], etaf_iface)],
           'neumann': [(facet_lookup['F_left'], Constant((0, 0))),
                       (facet_lookup['F_right'], Constant((0, 0)))]}

bcs_solid = {
    'elasticity': {
        'displacement': [],
        'traction': [(facet_lookup['I_bottom'], tractions_iface),
                    (facet_lookup['S2_left'], Constant((0,0))),
                    (facet_lookup['S1_left'], Constant((0,0)))],
        'displacement_x' : [(facet_lookup['S2_right'],Constant((0))),
                            (facet_lookup['S1_right'], Constant((0)))],
        'displacement_y' : [(facet_lookup['S2_top'], Constant(0))]                         
    },
    'darcy': {
        'pressure': [(facet_lookup['I_bottom'], ps_iface),
                     (facet_lookup['S1_left'], pSAS),
                     (facet_lookup['S2_left'], pSAS)],
        'flux': [(facet_lookup['S2_top'], Constant((0,0))),
                 (facet_lookup['S2_right'], Constant((0,0))),
                 (facet_lookup['S1_right'], Constant((0,0)))]     
    }
}



# Get the initial conditions ------------------------------------- FIXME
Es = Ws.sub(0).collapse()
Qs = Ws.sub(2).collapse()

# What is the difference between project and interpolate?
eta_s0 = project(Constant((0, 0)), Es)
eta_s00 = project(Constant((0, 0)), Es) # always at the begining of a time step
p_s0 = project(Constant(0), Qs)
u_s0 = project(Constant((0, 0)), Ws.sub(1).collapse()) 


uf_n = project(Constant((0, 0)), Wf.sub(0).collapse())
pf_n =  project(Constant(0), Wf.sub(1).collapse())


# Things for coupling
n_f, n_p = FacetNormal(mesh_f), FacetNormal(mesh_s)

sigma_f = lambda u, p, mu=fluid_parameters['mu']: 2*mu*sym(grad(u)) - p*Identity(2)

sigma_E = lambda eta, mu=solid_parameters['mu'], lmbda=solid_parameters['lmbda']: (
    2*mu*sym(grad(eta)) + lmbda*div(eta)*Identity(2)
)
sigma_p = lambda eta, p, alpha=solid_parameters['alpha']: sigma_E(eta)-alpha*p*Identity(2)

iface_tag = facet_lookup['I_bottom']
interface = (fluid_bdries, solid_bdries, iface_tag)

# Fenics won't let us move mesh with quadratic displacement so
Va_s = VectorFunctionSpace(mesh_s, 'CG', 1)


# Porosity variable 
porosity =FunctionSpace(mesh_s, 'CG', 1)




# Splitting loop
fluid_parameters['dt'] = 1E-3  # FIXME
solid_parameters['dt'] = 1E-3  # FIXME
time = 0.
timestep=0

Toutput=1E-3

tfinal=1

dt = fluid_parameters['dt']  

us_out, ps_out,etas_out  = File('./output/coupled3/us.pvd'), File('./output/coupled3/ps.pvd'), File('./output/coupled3/etas.pvd')
uf_out, pf_out = File('./output/coupled3/uf.pvd'), File('./output/coupled3/pf.pvd')

while time < tfinal:
    time += dt
    print('time', time)
    # Set sources if they are time dependent
    for expr in driving_expressions:
        hasattr(expr, 'time') and setattr(expr, 'time', time)
        hasattr(expr, 't1') and setattr(expr, 't1', time)
        hasattr(expr, 't2') and setattr(expr, 't2', time+dt)


    # Using traction solve fluid problem
    u_f, p_f = solve_fluid(Wf, f=Constant((0, 0)), u_n=uf_n, p_n=pf_n,  bdries=fluid_bdries, bcs=bcs_fluid,
                           parameters=fluid_parameters)
    
    # In biot interface we impose the continuity of fluid pressure
    transfer_into(ps_iface,
                  p_f,
                  interface)   

    # and continuity of normal stress
    transfer_into(tractions_iface,
                  -dot(sigma_f(u_f, p_f), n_f),
                  interface) 

    eta_s, u_s, p_s = solve_solid(Ws, f1=Constant((0, 0)), f2=Constant(0), eta_0=eta_s00, p_0=p_s0,
                                            bdries=solid_bdries, bcs=bcs_solid, parameters=solid_parameters)

    # Compute the porosity in the Biot domain

    # Extend solid deformation to 3D
    deformation = as_vector((eta_s[0],
                             eta_s[1],
                             Constant(0)))

    porosity_n=project(porosity_n+solid_parameters['alpha']*cyl.DivAxisym(deformation)+solid_parameters['s0']*(p_s-p_s0),porosity)



    # Impose the velocity in the fluid, given dU/dt of the interface and the percolation velocity at last time steps  
    transfer_into(velocity_f_iface, eta_s/Constant(dt) + u_s, interface)

    # Move the displacement for ALE
    transfer_into(etaf_iface, eta_s, interface)

    
    # Solve ALE problem in the fluid domain
    eta_f = solve_ale(Va, f=Constant((0, 0)), bdries=fluid_bdries, bcs=bcs_ale,
                      parameters=ale_parameters)
    
    # Move both domains(under some sensible condition) FIXME
    if True:
        ALE.move(mesh_s, interpolate(eta_s, Va_s))
        ALE.move(mesh_f, eta_f)



    # Reassign initial conditions
    # Update current solution
    uf_n.assign(u_f)
    pf_n.assign(p_f)
    eta_s0.assign(eta_s)
    u_s0.assign(u_s)
    p_s0.assign(p_s)

    # Save output
    timestep+=1
    if(timestep % int(Toutput/solid_parameters['dt']) == 0):
        u_s.rename("us", "tmp")
        eta_s.rename("etas", "tmp")
        p_s.rename("ps", "tmp")

        us_out << (u_s, time)
        ps_out << (p_s, time)
        etas_out << (eta_s, time)

        u_f.rename("uf", "tmp")
        p_f.rename("pf", "tmp")

        uf_out << (u_f, time)
        pf_out << (p_f, time)
