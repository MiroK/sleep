from sleep.utils import EmbeddedMesh
from sleep.mesh import load_mesh2d

from sleep.fbb_DD.solid import solve_solid
from sleep.fbb_DD.fluid import solve_fluid
from sleep.fbb_DD.ale import solve_ale
from dolfin import *

h5_filename = '../mesh/test/fbb_domain.h5'
# The mesh is typically generated by sleep/mesh/fbb_mesh.py
mesh, markers, lookup = load_mesh2d(h5_filename)
cell_f, facet_f = markers
cell_lookup, facet_lookup = lookup['cell'], lookup['facet']
# The mesh has 3 subdomains: corrsponding to fluid and two Biot domain. 
# Since our approach is to solve the subproblems isolated we now split 
# into fluid and solid meshes ...
mesh_f = EmbeddedMesh(cell_f, cell_lookup['F'])
mesh_s = EmbeddedMesh(cell_f, (cell_lookup['S1'], cell_lookup['S2']))
# ... and get their boundary markers

fluid_markers = ('F_left', 'F_bottom', 'F_right', 'I_bottom')
fluid_markers = tuple(facet_lookup[k] for k in fluid_markers)
fluid_bdries = mesh_f.translate_markers(facet_f, fluid_markers)

solid_markers = ('I_bottom', 'I_top', 'S1_left', 'S1_right', 'S2_left', 'S2_right', 'S2_top')
solid_markers = tuple(facet_lookup[k] for k in solid_markers)
solid_bdries = mesh_s.translate_markers(facet_f, solid_markers)

# Fluid problem setup ------------------------------------------------
Vf_elm = VectorElement('Lagrange', triangle, 2)
Qf_elm = FiniteElement('Lagrange', triangle, 1)
Wf_elm = MixedElement([Vf_elm, Qf_elm])
# We prescribed pressure inlet(left), traction free
# outlet, the stress on the solid interface is expected and on the bottom
# we want to fix velocity
pf_in = Constant(1) # NOTE: we specify (sigma_f.n).n and (sigma_f.n).tau = 0
uf_bdry = Constant((0, 0))             # FIXME
traction_f_iface = Constant((-1, 0))    # FIXME

bcs_fluid = {'dirichlet': [(facet_lookup['F_bottom'], uf_bdry)],
             'traction': [(facet_lookup['I_bottom'], traction_f_iface),
                          (facet_lookup['F_right'], Constant((0, 0)))],  # Outlet
             'pressure': [(facet_lookup['F_left'], (pf_in, Constant(0)))]}

# Just viscosity
fluid_parameters = {'mu': Constant(1.0)}  # FIXME
Wf = FunctionSpace(mesh_f, Wf_elm)

# Solid problem setup ------------------------------------------------
Es_elm = VectorElement('Lagrange', triangle, 2)
Vs_elm = FiniteElement('Raviart-Thomas', triangle, 1)
Qs_elm = FiniteElement('Discontinuous Lagrange', triangle, 0)
Ws_elm = MixedElement([Es_elm, Vs_elm, Qs_elm])

Ws = FunctionSpace(mesh_s, Ws_elm)

# We do not need to keep the facets marking the solid-solid interface
values = solid_bdries.array()
values[values == facet_lookup['I_top']] = 0

# Elasticity is traction free but at the bottom where we set displacements.
# For darcy, there are top and bottom pressures and the sides are no flux
ps_iface = Constant(0)  # FIXME
etas_iface = Constant((0, 0))  # FIXME
ps_out = Constant(0)  # FIXME

bcs_solid = {
  'elasticity': {
      'displacement': [(facet_lookup['I_bottom'], etas_iface)],
      'traction': [(facet_lookup[tag], Constant((0, 0)))
                  for tag in ('S1_left', 'S1_right', 'S2_left', 'S2_right', 'S2_top')]
    },
  'darcy': {
      'pressure': [(facet_lookup['I_bottom'], ps_iface), (facet_lookup['S2_top'], ps_out)],
      'flux': [(facet_lookup[tag], Constant((0, 0))) for tag in ('S1_left', 'S1_right', 'S2_left', 'S2_right')]
  }
}

# For parameters not that Biot has two subdomains (which are marked in the
# mesh so we difine discontinuous functions for them
solid_parameters = {'kappa_2': Constant(1), 'kappa_3': Constant(2),
                    'mu_2': Constant(1), 'mu_3': Constant(2),
                    'lmbda_2': Constant(1), 'lmbda_3': Constant(2),
                    'alpha_2': Constant(1), 'alpha_3': Constant(2),
                    's0_2': Constant(1), 's0_3': Constant(2)}

# NOTE: Here we do P0 projection
dxSolid = Measure('dx', domain=mesh_s, subdomain_data=mesh_s.marking_function)
CoefSpace = FunctionSpace(mesh_s, 'DG', 0)
q = TestFunction(CoefSpace)

for coef in ('kappa', 'mu', 'lmbda', 'alpha', 's0'):
    two, three = '%s_2' % coef, '%s_3' % coef
    # Remove
    two = solid_parameters.pop(two)
    three = solid_parameters.pop(three)

    form = (1/CellVolume(mesh_s))*two*q*dxSolid(2) + (1/CellVolume(mesh_s))*three*q*dxSolid(3)
    coef_function = Function(CoefSpace, assemble(form))

    solid_parameters[coef] = coef_function
    
# Add things for time stepping
solid_parameters['dt'] = 1E-6
solid_parameters['nsteps'] = 1
solid_parameters['T0'] = 0.


# Get the initial conditions
E = Ws.sub(0).collapse()
Q = Ws.sub(2).collapse()

eta_0 = interpolate(Constant((0, 0)), E)
p_0 = interpolate(Constant(0), Q)

ans = solve_solid(Ws, f1=Constant((0, 0)), f2=Constant(0), eta_0=eta_0, p_0=p_0,
                  bdries=solid_bdries, bcs=bcs_solid, parameters=solid_parameters)



# Ale problem setup --------------------------------------------------
Va_elm = VectorElement('Lagrange', triangle, 1)
ale_parameters = {'kappa': Constant(1.0)}

ale_u_bdry = Constant((0, 0))        # FIXME: The one that deforms the bottom wall
ale_u_iface = Constant((1, 1))   # FIXME: Displacement comming from solid

# Top bottom are prescribed displacement, and on sides we put 0 stresses
bcs_ale = {'dirichlet': [(facet_lookup['F_bottom'], ale_u_bdry),
                         (facet_lookup['I_bottom'], ale_u_iface)],
           'neumann': [(facet_lookup['F_left'], Constant((0, 0))),
                       (facet_lookup['F_right'], Constant((0, 0)))]}

Va = FunctionSpace(mesh_f, Va_elm)

# Splitting loop

#uf_h, pf_h = solve_fluid(Wf, f=Constant((0, 0)), bdries=fluid_bdries, bcs=bcs_fluid,
#                         parameters=fluid_parameters)

#eta_fh = solve_ale(Va, f=Constant((0, 0)), bdries=fluid_bdries, bcs=bcs_ale,
#                   parameters=ale_parameters)

